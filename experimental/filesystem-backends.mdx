---
title: Filesystem Backends
description: Details on the experimental filesystem backends for Flipt.
---

<Note>This feature was added in Flipt `v1.23.0`.</Note>

The following backend types are designed to support declarative management of feature flag state.
In particular, they're designed to support GitOps practices with minimal external dependencies.

This feature can be enabled via configuration parameters when running the `flipt` server binary.
As always, these parameters can be expressed via environment variables or Flipt's yaml configuration file:

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true
    ```

  </Tab>
</Tabs>

## Backend Types

There are currently two backend types we classify as being filesystem backends, `local` and `git`.
The `local` backend has been primarily developed to support a local development experience,
whereas, the `git` backend is intended for production and serves flag state directly from a configurable repository and Git reference (e.g. branch).

### Local

The purpose of this backend type is to support serving Flipt flag state directly from your local filesystem.
You can simply specify a relative or absolute directory in order to start a local Flipt instance and serve flag state.
This is particularly useful for local development and validation of flag state changes.

Flipt will periodically rebuild its state from the local disk every 10 seconds.

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    FLIPT_STORAGE_TYPE="local"
    FLIPT_STORAGE_LOCAL_PATH="."
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true

    storage:
      type: local
      local:
        path: "."
    ```

  </Tab>
</Tabs>

### Git

The `git` type backend is used to configure a target Git repository and Git reference to source feature flag state from.
The configuration contains fields for addressing the repository, configuring the target reference as well as adding authentication credentials.

Once a target repository and reference are configured, Flipt will poll the source repository on a periodic cadence.
This cadence is also configurable and defaults to 30 seconds.

Flipt will follow the configured reference (e.g. branch name) and keep up to date with new changes.

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    FLIPT_STORAGE_TYPE="git"
    FLIPT_STORAGE_GIT_REPOSITORY="https://github.com/predictab.le/config.git"
    FLIPT_STORAGE_GIT_REF="main"
    FLIPT_STORAGE_GIT_POLL_INTERVAL="30s"
    # for private repository access
    FLIPT_STORAGE_GIT_AUTHENTICATION_BASIC_USERNAME=...
    FLIPT_STORAGE_GIT_AUTHENTICATION_BASIC_PASSWORD=...
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true

    storage:
      type: git
      git:
        repository: "https://github.com/predictab.le/config.git"
        ref: "main"
        poll_interval: "30s"
        authentication:
          basic:
            username: ...
            password: ...
          token:
            access_token: ...
    ```

  </Tab>
</Tabs>

#### Authentication

Authentication enables the ability to leverage private Git repositories as flag state backends.
The `git` type backend supports both `basic` and `token` based authentication schemes.

<Note>
  When using GitHub and their PATs (Personal Access Tokens), `basic`
  authentication should be used. GitHub expects you to supply a valid `username`
  and provide your PAT as the `password` parameter.
</Note>

### Object

The object storage type supports using a hosted object storage service as the source of truth for Flipt state configuration.
Currently, Flipt supports the S3 API as a backend. This means the AWS S3 and open-source alternatives such as Minio can be leveraged as Flipt backends.

The contents of a target object storage bucket must contain Flipt state configuration files.
As with the `git` and `local` backend types, the same rules apply with regards to how Flipt will locate feature flag state in your target bucket.

Checkout the section below on [Flag State Configuration](#flag-state-configuration) for how Flipt decides which files in a target are considered for serving flag state.
With the object storage backend, Flipt will respect a file at the root of the target with the name `.flipt.yml` to serve as an index for locating flag state configuration in the bucket.
It will also use the same default strategy when the index isn't supplied (e.g. files name `features.yml` or `*.features.yml`).

#### S3

The S3 backend can be configured to serve state from a single bucket from a target S3 compatible API.

The following is an example of how to configure Flipt to leverage this backend type:

<Tabs>
  <Tab title="Environment Variable">

    ```bash
    FLIPT_EXPERIMENTAL_FILESYSTEM_STORAGE_ENABLED=true
    FLIPT_STORAGE_TYPE="object"
    FLIPT_STORAGE_OBJECT_TYPE="s3"
    FLIPT_STORAGE_OBJECT_S3_REGION="us-east-1"
    FLIPT_STORAGE_OBJECT_S3_BUCKET="flipt_feature_flags"
    FLIPT_STORAGE_OBJECT_S3_POLL_INTERVAL="1m"
    # for non-AWS hosted S3
    FLIPT_STORAGE_OBJECT_S3_ENDPOINT=http://localhost:9009
    ```

  </Tab>
  <Tab title="Configuration Yaml">

    ```yaml
    experimental:
      filesystem_storage:
        enabled: true

    storage:
      type: object
      object:
        type: s3
        s3:
          region: us-east-1
          bucket: flipt_feature_flags
          poll_interval: "30s"
          # for non-AWS hosted S3
          endpoint: http://localhost:9009
    ```

  </Tab>
</Tabs>

In addition to these Flipt configuration parameters, credentials will also be required for Flipt to authenticate with the target object store.
These should be provided as environment variables to the Flipt server process:

```bash
AWS_ACCESS_KEY_ID=...
AWS_SECRET_ACCESS_KEY=...
```

## Flag State Configuration

Each of Flipt's filesystem backends expects you to represent your feature flag configuration via a set of YAML files.
These files declaratively define what flags, segments, variants etc. exist and in what configuration.

### Locating Flag State

Flipt's filesystem backends allow you to define feature flags alongside other configurations in a shared directory, repository or object storage bucket.
In order to identify which files are intended for Flipt, it uses a naming scheme to index which are flag state files.
By default, Flipt will look for the following filename patterns when identifying files to attempt to parse as Flipt state:

- `**/features.yaml`
- `**/features.yml`
- `**/*.features.yaml`
- `**/*.features.yml`

Any file named `features.yaml`, `features.yml`, or with either extension `.features.yaml` or `.features.yml` is considered recursively from the root of your target.

If this naming convention doesn't work for you, it can be overridden by creating a file named `.flipt.yml` in the root of your target directory tree.
This file will be used to instruct Flipt on how to index your directory tree and find flag state files:

```yaml
version: "1.0"
include:
  - "**/features.yaml"
  - "**/features.yml"
  - "**/*.features.yaml"
  - "**/*.features.yml"
exclude: []
```

The index file contains two lists `include` and `exclude`. These can contain specific paths or glob matching patterns.
The indexing process first matches the `include` section and then filters that are set by the `exclude` section.

### Defining Flag State

<Info>
  Flipt flag state file format has been taken directly from Flipt's existing
  [import and export](/configuration/storage#import-export) flag state format.
  You can run `flipt export` on your existing Flipt instance, and then
  add/commit the result to a directory or Git repository to get started quickly.
  This can be used to migrate from a relational database backed instance of
  Flipt to a filesystem backed deployment with ease.
</Info>

```yaml features.yaml
namespace: backend
flags:
  - key: awesomeNewFeature
    name: Awesome New Feature
    enabled: true
    variants:
      - key: enabled
        name: Enabled
      - key: disabled
        name: Disabled
    rules:
      - segment: internal-users
        rank: 1
        distributions:
          - variant: enabled
            rollout: 100
      - segment: all-users
        rank: 2
        distributions:
          - variant: enabled
            rollout: 20
          - variant: disabled
            rollout: 80

segments:
  - key: internal-users
    name: Internal Users
    constraints:
      - type: STRING_COMPARISON_TYPE
        property: organization
        operator: eq
        value: internal
    match_type: ALL_MATCH_TYPE
  - key: all-users
    name: All Users
    match_type: ALL_MATCH_TYPE
```

Each file identified for use by Flipt represents the contents of a single namespace.
Multiple namespaces can be defined across multiple files.
You can organize these files however you like in your target directory.

<Tip>
  By defining different namespaces in different directories, you can leverage
  features such as GitHub's Codeowners. This gives you authorization mechanisms
  for managing contributions to Flipt state.
</Tip>

The file format currently consists of four top-level keys:

```yaml
version: "1.0" # a version for this file format
namespace: default # string identifying the resources collective namespace
flags: [] # [Flag] list of Flag definitions
segments: [] # [Segment] list of Segment definitions
```

#### Flags and Variants

<Info>
  All the resources in Flipt are explained in more depth in the
  [Concepts](/concepts) documentation page.
</Info>

The `flags` section is where your `Flag`, `Variant`, and `Rule` definitions live.
A Flag can have zero or many variants and zero or many rules.

```yaml
flags:
  - key: string
    name: string
    description: string
    enabled: bool
    variants: [] # [Variant] a list of variants
    rules: [] # [Rule] a list of rules
```

Variants belong to flags and they're nested within each flag definition in a list under the key `variants`.

```yaml
variants:
  - key: red
    name: Red
    description: The color red
```

#### Rules and Distributions

Rules also belong to Flags, however, they also reference specific Segments.
Their purpose is to declare the distribution of which variants are returned for a flag.
Rules require a matching segment key for the distribution to be considered.
Rules are ordered by `rank`, allowing you to configure multiple potential matches, first match wins.

For example, the following `rules` definition states that given a request matches the segment `newColorGroup` then it will return the variants `red` and `blue` in equal proportions (50/50 split).

```yaml
rules:
  - segment: newColorGroup
    rank: 1
    distributions:
      - variant: red
        rollout: 50
      - variant: blue
        rollout: 50
```

#### Segments and Constraints

Segments exist as a top-level key next to flags.
Their purpose is to provide classification of request contexts into different groups for matching on.
Segments are matched when their sets of constraints evaluate to `true`.
They can be re-used between different flags and their rule definitions.

```yaml
segments:
  - key: internal-users
    name: Internal Users
    constraints:
      - type: STRING_COMPARISON_TYPE
        property: organization
        operator: eq
        value: internal
    match_type: ALL_MATCH_TYPE
  - key: all-users
    name: All Users
    match_type: ALL_MATCH_TYPE
```

Here there are two segments `internal-users` and `all-users`.
The `internal-users` segment has a single constraint that matches the property `organization` found on an evaluation context with the string `internal`.
Given an evaluation API call is made with a context containing this property, the segment will match the request.

The `all-users` segment has no constraints and will match **all** requests.
This is useful because rules require a matching segment. This can be used as a catch-all segment.

**Constraint Types**

Constraints have comparison types to identify what type is expected of a property and its target value.
These types dictate the kinds of `operator`, which can be performed on the target property and value.
There currently exist a few types of constraints:

- `STRING_COMPARISON_TYPE`
- `NUMBER_COMPARISON_TYPE`
- `BOOLEAN_COMPARISON_TYPE`
- `DATETIME_COMPARISON_TYPE`

**Match Types**

Each segment has a `match_type` which signifies whether or not _all_ constraints must match or _any_ (at least one) must match.

- `ALL_MATCH_TYPE`
- `ANY_MATCH_TYPE`
